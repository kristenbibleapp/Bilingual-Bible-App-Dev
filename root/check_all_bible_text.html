<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Whole-Bible KJV Checker</title>
  <style>
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,sans-serif; padding:16px; }
    button { padding:10px 14px; font-size:16px; }
    .ok  { color:#2f8f2f; }
    .bad { color:#c62828; }
    .muted { color:#666; }
    #results { margin-top:12px; line-height:1.5; white-space:pre-wrap; }
    details { margin:8px 0; }
    summary { cursor:pointer; }
    /* diff colors */
    .del { background:#ffeaea; color:#b00020; }
    .add { background:#eaffea; color:#0b7a0b; }
    .eq  { }
  </style>
</head>
<body>
  <h1>Whole-Bible KJV Checker</h1>
  <p class="muted">Legend: ✓ match, ✗ diff (expand to see first difference). Red = differs in your text, Green = differs in reference.</p>
  <button id="run">Run full check</button>
  <div id="progress" class="muted" style="margin-top:8px;"></div>
  <div id="results"></div>

  <script>
    const ROOT_PREFIX = "./bible/kjv";
    const REF_BASE = "https://bible-api.com";

    const BOOKS = [
      ["Genesis",50],["Exodus",40],["Leviticus",27],["Numbers",36],["Deuteronomy",34],
      ["Joshua",24],["Judges",21],["Ruth",4],["1 Samuel",31],["2 Samuel",24],
      ["1 Kings",22],["2 Kings",25],["1 Chronicles",29],["2 Chronicles",36],["Ezra",10],
      ["Nehemiah",13],["Esther",10],["Job",42],["Psalms",150],["Proverbs",31],
      ["Ecclesiastes",12],["Song of Solomon",8],["Isaiah",66],["Jeremiah",52],["Lamentations",5],
      ["Ezekiel",48],["Daniel",12],["Hosea",14],["Joel",3],["Amos",9],
      ["Obadiah",1],["Jonah",4],["Micah",7],["Nahum",3],["Habakkuk",3],
      ["Zephaniah",3],["Haggai",2],["Zechariah",14],["Malachi",4],
      ["Matthew",28],["Mark",16],["Luke",24],["John",21],["Acts",28],
      ["Romans",16],["1 Corinthians",16],["2 Corinthians",13],["Galatians",6],["Ephesians",6],
      ["Philippians",4],["Colossians",4],["1 Thessalonians",5],["2 Thessalonians",3],["1 Timothy",6],
      ["2 Timothy",4],["Titus",3],["Philemon",1],["Hebrews",13],["James",5],
      ["1 Peter",5],["2 Peter",3],["1 John",5],["2 John",1],["3 John",1],
      ["Jude",1],["Revelation",22]
    ];

    const progress = msg => document.getElementById("progress").textContent = msg;
    const resultsDiv = document.getElementById("results");
    const wait = ms => new Promise(r => setTimeout(r, ms));

    // ---------- Normalizers ----------
    const stripHtml        = s => s.replace(/<[^>]+>/g,"");
    const stripPilcrow     = s => s.replace(/¶/g,"");
    const dropBracketChars = s => s.replace(/[\[\]\(\)\{\}«»‹›]/g, ""); // keep words, drop brackets
    const stripLeadNum     = s => s.replace(/^\s*\(?\d+\)?[.:)]\s*/,"");

    // collapse hyphens/spaces for compounds: Beth-shemesh == Bethshemesh; first born == firstborn
    function collapseCompounds(s){
      s = s.replace(/-/g,"");                 // remove hyphens entirely
      s = s.replace(/\bfirst\s+born\b/g,"firstborn");
      return s;
    }

    // Loose canonical form used for comparison
    function normalizeLoose(s){
      s = (s||"")
        .replace(/\u201c|\u201d/g,'"')
        .replace(/\u2018|\u2019/g,"'")
        .toLowerCase();

      s = stripHtml(s);
      s = stripPilcrow(s);
      s = dropBracketChars(s);  // keep inside text
      s = stripLeadNum(s);

      s = collapseCompounds(s);
      s = s.replace(/\bthroughly\b/g,"thoroughly"); // KJV variant
      s = s.replace(/\b(\w+?)s\b/g,"$1");           // simple plurals

      s = s.replace(/[^\w\s]/g," "); // drop remaining punctuation
      s = s.replace(/\s+/g," ").trim();
      return s;
    }

    // Tokenize a verse into {orig, norm} tokens for highlighting
    function tokenizeForDiff(s){
      const rawTokens = (s||"").split(/\s+/);
      const tokens = [];
      for(const t of rawTokens){
        const n = normalizeLoose(t);
        if(n.length){
          tokens.push({ orig:t, norm:n });
        }else{
          if(/[^\s]/.test(t)) tokens.push({ orig:t, norm:"" }); // preserve visible punct
        }
      }
      return tokens;
    }

    // Longest Common Subsequence on normalized tokens
    function lcs(a, b){
      const m=a.length, n=b.length;
      const dp = Array.from({length:m+1},()=>Array(n+1).fill(0));
      for(let i=1;i<=m;i++){
        for(let j=1;j<=n;j++){
          if(a[i-1].norm && a[i-1].norm === b[j-1].norm) dp[i][j]=dp[i-1][j-1]+1;
          else dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
        }
      }
      const matches=[];
      let i=m, j=n;
      while(i>0 && j>0){
        if(a[i-1].norm && a[i-1].norm === b[j-1].norm){ matches.push([i-1,j-1]); i--; j--; }
        else if(dp[i-1][j] >= dp[i][j-1]) i--;
        else j--;
      }
      return matches.reverse();
    }

    // Build HTML with spans: words in A not matched -> .del; in B not matched -> .add
    function renderDiffHTML(localStr, refStr){
      const A = tokenizeForDiff(localStr);
      const B = tokenizeForDiff(refStr);
      const matches = lcs(A,B);

      const aMatchIdx = new Set(matches.map(([ai]) => ai));
      const bMatchIdx = new Set(matches.map(([,bi]) => bi));

      const aHtml = A.map((tok, idx) => {
        if(!tok.norm) return tok.orig;
        return aMatchIdx.has(idx) ? tok.orig : `<span class="del">${tok.orig}</span>`;
      }).join(" ");

      const bHtml = B.map((tok, idx) => {
        if(!tok.norm) return tok.orig;
        return bMatchIdx.has(idx) ? tok.orig : `<span class="add">${tok.orig}</span>`;
      }).join(" ");

      return { aHtml, bHtml };
    }

    function firstDiff(localArr, refArr){
      const n = Math.min(localArr.length, refArr.length);
      for(let i=0;i<n;i++){
        if(normalizeLoose(localArr[i]) !== normalizeLoose(refArr[i])){
          return { v:i+1, local:localArr[i], ref:refArr[i] };
        }
      }
      if(localArr.length !== refArr.length){
        return { v:n+1, local:`[local length=${localArr.length}]`, ref:`[ref length=${refArr.length}]` };
      }
      return null;
    }

    // ---------- Loaders ----------
    async function fetchLocalChapter(book,ch){
      const encBook = encodeURIComponent(book);
      const urls = [
        `${ROOT_PREFIX}/${encBook}/${String(ch).padStart(2,"0")}.json`,
        `${ROOT_PREFIX}/${encBook}/${ch}.json`
      ];
      let lastErr = null;
      for(const url of urls){
        try{
          const r = await fetch(url);
          if(!r.ok){ lastErr = new Error(`LOCAL ${book} ${ch} HTTP ${r.status} @ ${url}`); continue; }
          let js;
          try { js = await r.json(); }
          catch { throw new Error(`LOCAL ${book} ${ch} JSON parse error @ ${url}`); }

          let texts = [];
          if(Array.isArray(js?.verses)){
            texts = js.verses.map(v => (typeof v === "object" ? (v.text ?? "") : String(v)));
          }else if(js && typeof js === "object"){
            texts = Object.keys(js).sort((a,b)=>+a-+b).map(k => String(js[k]));
          }else{
            throw new Error(`LOCAL ${book} ${ch} unknown JSON shape @ ${url}`);
          }
          return texts;
        }catch(e){ lastErr = e; }
      }
      throw lastErr || new Error(`LOCAL ${book} ${ch} not found`);
    }

    async function fetchRefChapter(book,ch){
      const qBook = encodeURIComponent(book);
      const direct = `${REF_BASE}/${qBook}%20${ch}?translation=kjv`;
      const proxy  = `https://r.jina.ai/http://bible-api.com/${qBook}%20${ch}?translation=kjv`;

      async function tryUrl(url,label,attempt){
        const r = await fetch(url);
        if(!r.ok) throw new Error(`REF ${label} ${book} ${ch} HTTP ${r.status} (try ${attempt})`);
        let js;
        try { js = await r.json(); }
        catch { throw new Error(`REF ${label} ${book} ${ch} parse (try ${attempt})`); }
        const verses = Array.isArray(js.verses) ? js.verses : [];
        if(!verses.length) throw new Error(`REF ${label} ${book} ${ch} empty (try ${attempt})`);
        return verses.map(v => v.text ?? "");
      }

      // up to 4 attempts: 2 direct, then 2 via proxy; if all fail, skip gracefully
      for(let attempt=1; attempt<=4; attempt++){
        try{
          if(attempt <= 2){
            return await tryUrl(direct, "DIRECT", attempt);
          }else{
            return await tryUrl(proxy,  "PROXY",  attempt);
          }
        }catch(e){
          if(attempt === 4) return null; // graceful skip for this chapter
          await wait(800 + Math.random()*700);
        }
      }
    }

    // ---------- Runner ----------
    async function run(){
      resultsDiv.textContent = "";
      let total=0, ok=0, bad=0, missing=0, errs=0, skipped=0;

      for(const [book,maxCh] of BOOKS){
        const head = document.createElement("div");
        head.innerHTML = `<strong>${book}</strong>`;
        resultsDiv.appendChild(head);

        for(let ch=1; ch<=maxCh; ch++){
          total++;
          progress(`Checking ${book} ${ch} …`);
          try{
            const local = await fetchLocalChapter(book, ch);
            const ref   = await fetchRefChapter(book, ch);

            if(!ref){
              skipped++;
              const line = document.createElement("div");
              line.className = "muted";
              line.textContent = `• ${book} ${ch} -- skipped (reference unavailable)`;
              resultsDiv.appendChild(line);
            } else {
              const diff = firstDiff(local, ref);
              const line = document.createElement("div");

              if(!diff){
                ok++;
                line.className = "ok";
                line.textContent = `✓ ${book} ${ch}`;
              }else{
                bad++;
                line.className = "bad";

                const { aHtml, bHtml } = renderDiffHTML(diff.local, diff.ref);

                const det = document.createElement("details");
                const sum = document.createElement("summary");
                sum.textContent = `✗ ${book} ${ch} (first diff v${diff.v})`;

                const body = document.createElement("div");
                body.innerHTML = `<div><em>Local:</em> ${aHtml}</div><div><em>Ref:</em> ${bHtml}</div>`;

                det.appendChild(sum); det.appendChild(body); line.appendChild(det);
              }
              resultsDiv.appendChild(line);
            }
          }catch(e){
            errs++;
            if(String(e).includes("LOCAL")) missing++;
            const line = document.createElement("div");
            line.className = "bad";
            line.textContent = `! ${book} ${ch} -- ${e.message}`;
            resultsDiv.appendChild(line);
          }

          await wait(500 + Math.random()*200);
        }
      }
      progress(`Done. Total: ${total} | ✓ ${ok} | ✗ ${bad} | Skipped(ref): ${skipped} | Missing(local): ${missing} | Errors: ${errs}`);
    }

    document.getElementById("run").addEventListener("click", run);
  </script>
</body>
</html>